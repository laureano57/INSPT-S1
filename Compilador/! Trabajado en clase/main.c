// Para usar isgraph
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ####################################################################################################################
// #################################################### Constantes ####################################################
// ####################################################################################################################

// Longitud neta, sin los apóstrofos ni el cero final
#define MAX_LONGITUD_CADENA 128

// Longitud de la tabla de identificadores
#define MAX_CANT_IDENT 1024

// Archivo de test harcodeado
#define ARCHIVO "BIEN-00.PL0"

// Salida binaria del compilador
#define OUTPUT_FILE "output.bin"

// ####################################################################################################################
// ################################################## Tipos de datos ##################################################
// ####################################################################################################################

// Byte de chars sin signo para que se usen todos los bits para representar al numero
typedef unsigned char byte;

typedef struct memoria {
  int posicion;
  byte * bytesArray;
} memoria;

typedef enum {
  ABREPAREN,
  ASIGNACION,
  BEGIN,
  CADENA,
  CALL,
  CIERRAPAREN,
  COMA,
  CONST,
  DISTINTO,
  DIVIDIDO,
  DO,
  END,
  FIN_DE_ARCHIVO,
  IDENT,
  IF,
  IGUAL,
  MAS,
  MAYOR,
  MAYORIGUAL,
  MENOR,
  MENORIGUAL,
  MENOS,
  NULO,
  NUMERO,
  ODD,
  POR,
  PROCEDURE,
  PTOCOMA,
  PUNTO,
  READLN,
  THEN,
  VAR,
  WHILE,
  WRITE,
  WRITELN,
} tTerminal;

typedef struct {
  tTerminal simbolo;
  char cadena[MAX_LONGITUD_CADENA + 3]; // Mas los apostrofos y el cero final
} tSimbolo;

typedef struct {
  tTerminal tipo;
  char nombre[MAX_LONGITUD_CADENA + 3];
  int valor;
} tEntradaTabla;

typedef tEntradaTabla tablaDeIdent[MAX_CANT_IDENT];

// ####################################################################################################################
// ###################################################### Helpers ######################################################
// ####################################################################################################################

tSimbolo aLex(FILE *);

void imprimir(tSimbolo);

void concatenar(char *, char);

void uppercase(char *);

void error(int, tSimbolo);

int buscarIdent(char *, tablaDeIdent, int, int);

int esIdentDeTipo(char *, tablaDeIdent, int, tTerminal);

void cargarByte(memoria **, byte);

void cargarInt(memoria **, int);

void cargarHeader(memoria **);

void getNombre(char *, char **);

// ####################################################################################################################
// ####################################### Funciones del analizador sintactico #######################################
// ####################################################################################################################

tSimbolo programa(tSimbolo, FILE *archivo, memoria **);
tSimbolo bloque(tSimbolo, FILE *archivo, memoria **, tablaDeIdent, int base);
tSimbolo proposicion(tSimbolo, FILE *archivo, memoria **, tablaDeIdent, int posUltimoIdent);
tSimbolo condicion(tSimbolo, FILE *archivo, memoria **, tablaDeIdent, int posUltimoIdent);
tSimbolo expresion(tSimbolo, FILE *archivo, memoria **, tablaDeIdent, int posUltimoIdent);
tSimbolo termino(tSimbolo, FILE *archivo, memoria **, tablaDeIdent, int posUltimoIdent);
tSimbolo factor(tSimbolo, FILE *archivo, memoria **, tablaDeIdent, int posUltimoIdent);

// ####################################################################################################################
// ####################################################### MAIN #######################################################
// ####################################################################################################################

int main(int argc, char *argv[]) {
  // Array de bytes donde se van a ir volcando los datos
  byte bytesArray[8192];

  // Inicializo memArray para empezar a guardar bytes en bytesArray (array de salida)
  memoria *memArray = malloc(sizeof(memoria));
  memArray->posicion = 0;
  memArray->bytesArray = bytesArray;

  // Cargo el header y los bytes de entrada y salida al array de bytes
  // cargarHeader(&memArray);
  // Escribe bytes a la salida
  // dumpToFile(memArray);

  // Parseo nombre de archivo PL0 (para definir output filename)
  // Queda comentado hasta que se empiece a usar el ejecutable con un parametro,
  // sino explota:
  // char *outputFilename;
  // getNombre(argv[0], &outputFilename);

  // if (argc != 2) {
  //     printf("Uso: lexer FUENTE.PL0\n");
  // } else {
  FILE *archivo;
  // archivo = fopen(argv[1], "r");
  archivo = fopen(ARCHIVO, "r"); // Harcodea nombre de archivo
  if (archivo == NULL) {
    printf("Error de apertura del archivo [%s].\n", argv[1]);
  } else {
    tSimbolo s;
    s = aLex(archivo);
    s = programa(s, archivo, &memArray);
    if (s.simbolo == FIN_DE_ARCHIVO) {
      printf("Archivo procesado exitosamente\n");
    } else error(0, s);

  // }
  }
  return 0;
}

// ####################################################################################################################
// ##################################################### Helpers #####################################################
// ####################################################################################################################

void imprimir(tSimbolo simb) {
  printf("Cadena leida: \"%s\"\t Simbolo correspondiente: ", simb.cadena);
  switch (simb.simbolo) {
  case ABREPAREN:
    printf("ABREPAREN");
    break;
  case ASIGNACION:
    printf("ASIGNACION");
    break;
  case BEGIN:
    printf("BEGIN");
    break;
  case CADENA:
    printf("CADENA");
    break;
  case CALL:
    printf("CALL");
    break;
  case CIERRAPAREN:
    printf("CIERRAPAREN");
    break;
  case COMA:
    printf("COMA");
    break;
  case CONST:
    printf("CONST");
    break;
  case DISTINTO:
    printf("DISTINTO");
    break;
  case DIVIDIDO:
    printf("DIVIDIDO");
    break;
  case DO:
    printf("DO");
    break;
  case END:
    printf("END");
    break;
  case FIN_DE_ARCHIVO:
    printf("FIN_DE_ARCHIVO");
    break;
  case IDENT:
    printf("IDENT");
    break;
  case IF:
    printf("IF");
    break;
  case IGUAL:
    printf("IGUAL");
    break;
  case MAS:
    printf("MAS");
    break;
  case MAYOR:
    printf("MAYOR");
    break;
  case MAYORIGUAL:
    printf("MAYORIGUAL");
    break;
  case MENOR:
    printf("MENOR");
    break;
  case MENORIGUAL:
    printf("MENORIGUAL");
    break;
  case MENOS:
    printf("MENOS");
    break;
  case NULO:
    printf("NULO");
    break;
  case NUMERO:
    printf("NUMERO");
    break;
  case ODD:
    printf("ODD");
    break;
  case POR:
    printf("POR");
    break;
  case PROCEDURE:
    printf("PROCEDURE");
    break;
  case PTOCOMA:
    printf("PTOCOMA");
    break;
  case PUNTO:
    printf("PUNTO");
    break;
  case READLN:
    printf("READLN");
    break;
  case THEN:
    printf("THEN");
    break;
  case VAR:
    printf("VAR");
    break;
  case WHILE:
    printf("WHILE");
    break;
  case WRITE:
    printf("WRITE");
    break;
  case WRITELN:
    printf("WRITELN");
    break;
  }
  printf("\n");
}

void concatenar(char *s, char c) {
  if (strlen(s) < MAX_LONGITUD_CADENA + 2) { // Si cabe uno mas
    for (; *s; s++);
    *s++ = c;
    *s++ = '\0';
  }
}

void uppercase(char *s) {
  for (; *s; s++)
    *s = toupper(*s);
}

void error(int codigo, tSimbolo s) {
  switch (codigo) {
  case 0:
    printf("Error al leer final de archivo: %s\n", s.cadena);
    break;
  case 1:
    printf("Error, se esperaba un PUNTO: %s\n", s.cadena);
    break;
  case 2:
    printf("Error, se esperaba un IDENT: %s\n", s.cadena);
    break;
  case 3:
    printf("Error, se esperaba un IGUAL: %s\n", s.cadena);
    break;
  case 4:
    printf("Error, se esperaba un NUMERO: %s\n", s.cadena);
    break;
  case 5:
    printf("Error, se esperaba un PTOCOMA: %s\n", s.cadena);
    break;
  case 6:
    printf("Error, se esperaba una ASIGNACION: %s\n", s.cadena);
    break;
  case 7:
    printf("Error, se esperaba un END: %s\n", s.cadena);
    break;
  case 8:
    printf("Error, se esperaba un THEN: %s\n", s.cadena);
    break;
  case 9:
    printf("Error, se esperaba un DO: %s\n", s.cadena);
    break;
  case 10:
    printf("Error, se esperaba un ABREPAREN: %s\n", s.cadena);
    break;
  case 11:
    printf("Error, se esperaba un CIERRAPAREN: %s\n", s.cadena);
    break;
  case 12:
    printf("Error, se esperaba un operador relacional: %s\n", s.cadena);
    break;
  case 13:
    printf("Error semantico, se repite el identificador: %s\n", s.cadena);
    break;
  case 14:
    printf("Error semantico, se esperaba un VAR: %s\n", s.cadena);
    break;
    case 15:
    printf("Error semantico, el identificador %s no esta declarado.\n", s.cadena);
    break;
  case 16:
    printf("Error semantico, el identificador %s no es de tipo PROCEDURE\n", s.cadena);
    break;
  case 17:
    printf("Error semantico, el identificador \"%s\" no es de tipo VAR\n", s.cadena);
    break;
  case 18:
    printf("Error semantico, el identificador \"%s\" no es de tipo NUMERO\n", s.cadena);
    break;
  default:
    printf("Error generico\n");
    break;
  }
  exit(1);
}

// Busca identificador en la tabla de identificadores y devuelve la posicion o -1
int buscarIdent(char *id, tablaDeIdent tabla, int posPrimerIdent, int posUltimoIdent) {

  char cadenaAux[MAX_LONGITUD_CADENA + 3];
  strcpy(cadenaAux, id);
  uppercase(cadenaAux);
  // SIEMPRE lee de abajo para arriba, para encontrar la ultima definicion de la
  // variable o procedimiento
  int i = posUltimoIdent;
  while (i >= posPrimerIdent && strcmp(cadenaAux, tabla[i].nombre) != 0)
    i--;
  return (i >= posPrimerIdent ? i : -1);
}

// Busca un identificador en la tabla, devuelve 1 si es del tipo buscado (PROCEDURE, CONST, VAR), caso contrario 0
int esIdentDeTipo(char *cad, tablaDeIdent tabla, int posUltimoIdent, tTerminal tipo) {
  for (int i = posUltimoIdent; i >= 0; i--) {
    if ((strcmp(tabla[i].nombre, cad) == 0) && (tabla[i].tipo == tipo)) return 1;
  }
  return 0;
}

// Carga un byte en el array de memoria e incrementa la posicion del indice
void cargarByte(memoria **mem, byte dato) {
  int i = (*mem)->posicion;
  (*mem)->bytesArray[i] = dato;
  (*mem)->posicion += 1;
}

// Carga un int (4 bytes) en el array de memoria e incrementa la posicion del indice
void cargarInt(memoria **mem, int dato) {
  int i = (*mem)->posicion;
  unsigned int k = 4294967295; // -1 en 4 bytes (FF FF FF FF)
  unsigned int d;

  if (dato < 0) {
    d = k + dato + 1;
  } else {
    d = (unsigned int) dato;
  }
  // Como la PC es little endian, se insertan al reves, de a pares
  cargarByte(mem, d % 0x100); // Ultimos 2 digitos
  cargarByte(mem, d / 0x100 % 0x100); // los 2 siguientes
  cargarByte(mem, d / 0x10000 % 0x100); // los 2 siguientes
  cargarByte(mem, d / 0x1000000 % 0x100); // los 2 siguientes
}

// Carga un byte en el array de memoria en la posicion dada
void cargarByteEn(memoria **mem, byte dato, int pos) {
  (*mem)->bytesArray[pos] = dato;
}

// Carga un int (4 bytes) en el array de memoria en la posicion dada
void cargarIntEn(memoria **mem, int dato, int pos) {
  unsigned int k = 4294967295; // -1 en 4 bytes (FF FF FF FF)
  unsigned int d;

  if (dato < 0) {
    d = k + dato + 1;
  } else {
    d = (unsigned int) dato;
  }

  // Como la PC es little endian, se insertan al reves, de a pares
  cargarByteEn(mem, d % 0x100, pos); // Ultimos 2 digitos
  cargarByteEn(mem, d / 0x100 % 0x100, pos); // los 2 siguientes
  cargarByteEn(mem, d / 0x10000 % 0x100, pos); // los 2 siguientes
  cargarByteEn(mem, d / 0x1000000 % 0x100, pos); // los 2 siguientes
}

// Ni idea para que se usa, es para la parte final, donde se arreglan las posiciones de memoria
int leerEnteroDe(memoria **mem, int pos) {
  return  (*mem)->bytesArray[pos] +
          (*mem)->bytesArray[pos] * 256 +
          (*mem)->bytesArray[pos] * 256 * 256 +
          (*mem)->bytesArray[pos] * 256 * 256 * 256;
}

// Carga los bytes del header al array de bytes
void cargarHeader(memoria **mem) {
  // Header de bytes para linux ELF
  byte header[] = { 0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x84, 0x04, 0x08, 0x34, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x20, 0x00, 0x01, 0x00, 0x28, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x04, 0x08, 0x00, 0x80, 0x04, 0x08, 0x97, 0x05, 0x00, 0x00, 0x97, 0x05, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x2e, 0x73, 0x68, 0x73, 0x74, 0x72, 0x74, 0x61, 0x62, 0x00, 0x2e, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0xe0, 0x80, 0x04, 0x08, 0xe0, 0x00, 0x00, 0x00, 0xb7, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x51, 0x53, 0x50, 0xb8, 0x04, 0x00, 0x00, 0x00, 0xbb, 0x01, 0x00, 0x00, 0x00, 0x89, 0xe1, 0xba, 0x01, 0x00, 0x00, 0x00, 0xcd, 0x80, 0x58, 0x5b, 0x59, 0x5a, 0xc3, 0x55, 0x89, 0xe5, 0x81, 0xec, 0x24, 0x00, 0x00, 0x00, 0x52, 0x51, 0x53, 0xb8, 0x36, 0x00, 0x00, 0x00, 0xbb, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x01, 0x54, 0x00, 0x00, 0x8d, 0x55, 0xdc, 0xcd, 0x80, 0x81, 0x65, 0xe8, 0xf5, 0xff, 0xff, 0xff, 0xb8, 0x36, 0x00, 0x00, 0x00, 0xbb, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x02, 0x54, 0x00, 0x00, 0x8d, 0x55, 0xdc, 0xcd, 0x80, 0x31, 0xc0, 0x50, 0xb8, 0x03, 0x00, 0x00, 0x00, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x89, 0xe1, 0xba, 0x01, 0x00, 0x00, 0x00, 0xcd, 0x80, 0x81, 0x4d, 0xe8, 0x0a, 0x00, 0x00, 0x00, 0xb8, 0x36, 0x00, 0x00, 0x00, 0xbb, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x02, 0x54, 0x00, 0x00, 0x8d, 0x55, 0xdc, 0xcd, 0x80, 0x58, 0x5b, 0x59, 0x5a, 0x89, 0xec, 0x5d, 0xc3, 0xb8, 0x04, 0x00, 0x00, 0x00, 0xbb, 0x01, 0x00, 0x00, 0x00, 0xcd, 0x80, 0xc3, 0x90, 0x90, 0x90, 0xb0, 0x0a, 0xe8, 0x59, 0xff, 0xff, 0xff, 0xc3, 0x04, 0x30, 0xe8, 0x51, 0xff, 0xff, 0xff, 0xc3, 0x3d, 0x00, 0x00, 0x00, 0x80, 0x75, 0x4e, 0xb0, 0x2d, 0xe8, 0x42, 0xff, 0xff, 0xff, 0xb0, 0x02, 0xe8, 0xe3, 0xff, 0xff, 0xff, 0xb0, 0x01, 0xe8, 0xdc, 0xff, 0xff, 0xff, 0xb0, 0x04, 0xe8, 0xd5, 0xff, 0xff, 0xff, 0xb0, 0x07, 0xe8, 0xce, 0xff, 0xff, 0xff, 0xb0, 0x04, 0xe8, 0xc7, 0xff, 0xff, 0xff, 0xb0, 0x08, 0xe8, 0xc0, 0xff, 0xff, 0xff, 0xb0, 0x03, 0xe8, 0xb9, 0xff, 0xff, 0xff, 0xb0, 0x06, 0xe8, 0xb2, 0xff, 0xff, 0xff, 0xb0, 0x04, 0xe8, 0xab, 0xff, 0xff, 0xff, 0xb0, 0x08, 0xe8, 0xa4, 0xff, 0xff, 0xff, 0xc3, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x7d, 0x0b, 0x50, 0xb0, 0x2d, 0xe8, 0xec, 0xfe, 0xff, 0xff, 0x58, 0xf7, 0xd8, 0x3d, 0x0a, 0x00, 0x00, 0x00, 0x0f, 0x8c, 0xef, 0x00, 0x00, 0x00, 0x3d, 0x64, 0x00, 0x00, 0x00, 0x0f, 0x8c, 0xd1, 0x00, 0x00, 0x00, 0x3d, 0xe8, 0x03, 0x00, 0x00, 0x0f, 0x8c, 0xb3, 0x00, 0x00, 0x00, 0x3d, 0x10, 0x27, 0x00, 0x00, 0x0f, 0x8c, 0x95, 0x00, 0x00, 0x00, 0x3d, 0xa0, 0x86, 0x01, 0x00, 0x7c, 0x7b, 0x3d, 0x40, 0x42, 0x0f, 0x00, 0x7c, 0x61, 0x3d, 0x80, 0x96, 0x98, 0x00, 0x7c, 0x47, 0x3d, 0x00, 0xe1, 0xf5, 0x05, 0x7c, 0x2d, 0x3d, 0x00, 0xca, 0x9a, 0x3b, 0x7c, 0x13, 0xba, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x00, 0xca, 0x9a, 0x3b, 0xf7, 0xfb, 0x52, 0xe8, 0x30, 0xff, 0xff, 0xff, 0x58, 0xba, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x00, 0xe1, 0xf5, 0x05, 0xf7, 0xfb, 0x52, 0xe8, 0x1d, 0xff, 0xff, 0xff, 0x58, 0xba, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x80, 0x96, 0x98, 0x00, 0xf7, 0xfb, 0x52, 0xe8, 0x0a, 0xff, 0xff, 0xff, 0x58, 0xba, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x40, 0x42, 0x0f, 0x00, 0xf7, 0xfb, 0x52, 0xe8, 0xf7, 0xfe, 0xff, 0xff, 0x58, 0xba, 0x00, 0x00, 0x00, 0x00, 0xbb, 0xa0, 0x86, 0x01, 0x00, 0xf7, 0xfb, 0x52, 0xe8, 0xe4, 0xfe, 0xff, 0xff, 0x58, 0xba, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x10, 0x27, 0x00, 0x00, 0xf7, 0xfb, 0x52, 0xe8, 0xd1, 0xfe, 0xff, 0xff, 0x58, 0xba, 0x00, 0x00, 0x00, 0x00, 0xbb, 0xe8, 0x03, 0x00, 0x00, 0xf7, 0xfb, 0x52, 0xe8, 0xbe, 0xfe, 0xff, 0xff, 0x58, 0xba, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x64, 0x00, 0x00, 0x00, 0xf7, 0xfb, 0x52, 0xe8, 0xab, 0xfe, 0xff, 0xff, 0x58, 0xba, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x0a, 0x00, 0x00, 0x00, 0xf7, 0xfb, 0x52, 0xe8, 0x98, 0xfe, 0xff, 0xff, 0x58, 0xe8, 0x92, 0xfe, 0xff, 0xff, 0xc3, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xb8, 0x01, 0x00, 0x00, 0x00, 0xbb, 0x00, 0x00, 0x00, 0x00, 0xcd, 0x80, 0x90, 0x90, 0x90, 0x90, 0xb9, 0x00, 0x00, 0x00, 0x00, 0xb3, 0x03, 0x51, 0x53, 0xe8, 0xde, 0xfd, 0xff, 0xff, 0x5b, 0x59, 0x3c, 0x0a, 0x0f, 0x84, 0x34, 0x01, 0x00, 0x00, 0x3c, 0x7f, 0x0f, 0x84, 0x94, 0x00, 0x00, 0x00, 0x3c, 0x2d, 0x0f, 0x84, 0x09, 0x01, 0x00, 0x00, 0x3c, 0x30, 0x7c, 0xdb, 0x3c, 0x39, 0x7f, 0xd7, 0x2c, 0x30, 0x80, 0xfb, 0x00, 0x74, 0xd0, 0x80, 0xfb, 0x02, 0x75, 0x0c, 0x81, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x75, 0x04, 0x3c, 0x00, 0x74, 0xbf, 0x80, 0xfb, 0x03, 0x75, 0x0a, 0x3c, 0x00, 0x75, 0x04, 0xb3, 0x00, 0xeb, 0x02, 0xb3, 0x01, 0x81, 0xf9, 0xcc, 0xcc, 0xcc, 0x0c, 0x7f, 0xa8, 0x81, 0xf9, 0x34, 0x33, 0x33, 0xf3, 0x7c, 0xa0, 0x88, 0xc7, 0xb8, 0x0a, 0x00, 0x00, 0x00, 0xf7, 0xe9, 0x3d, 0x08, 0x00, 0x00, 0x80, 0x74, 0x11, 0x3d, 0xf8, 0xff, 0xff, 0x7f, 0x75, 0x13, 0x80, 0xff, 0x07, 0x7e, 0x0e, 0xe9, 0x7f, 0xff, 0xff, 0xff, 0x80, 0xff, 0x08, 0x0f, 0x8f, 0x76, 0xff, 0xff, 0xff, 0xb9, 0x00, 0x00, 0x00, 0x00, 0x88, 0xf9, 0x80, 0xfb, 0x02, 0x74, 0x04, 0x01, 0xc1, 0xeb, 0x03, 0x29, 0xc8, 0x91, 0x88, 0xf8, 0x51, 0x53, 0xe8, 0xcb, 0xfd, 0xff, 0xff, 0x5b, 0x59, 0xe9, 0x53, 0xff, 0xff, 0xff, 0x80, 0xfb, 0x03, 0x0f, 0x84, 0x4a, 0xff, 0xff, 0xff, 0x51, 0x53, 0xb0, 0x08, 0xe8, 0x0a, 0xfd, 0xff, 0xff, 0xb0, 0x20, 0xe8, 0x03, 0xfd, 0xff, 0xff, 0xb0, 0x08, 0xe8, 0xfc, 0xfc, 0xff, 0xff, 0x5b, 0x59, 0x80, 0xfb, 0x00, 0x75, 0x07, 0xb3, 0x03, 0xe9, 0x25, 0xff, 0xff, 0xff, 0x80, 0xfb, 0x02, 0x75, 0x0f, 0x81, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x75, 0x07, 0xb3, 0x03, 0xe9, 0x11, 0xff, 0xff, 0xff, 0x89, 0xc8, 0xb9, 0x0a, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x7d, 0x08, 0xf7, 0xd8, 0xf7, 0xf9, 0xf7, 0xd8, 0xeb, 0x02, 0xf7, 0xf9, 0x89, 0xc1, 0x81, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x85, 0xe6, 0xfe, 0xff, 0xff, 0x80, 0xfb, 0x02, 0x0f, 0x84, 0xdd, 0xfe, 0xff, 0xff, 0xb3, 0x03, 0xe9, 0xd6, 0xfe, 0xff, 0xff, 0x80, 0xfb, 0x03, 0x0f, 0x85, 0xcd, 0xfe, 0xff, 0xff, 0xb0, 0x2d, 0x51, 0x53, 0xe8, 0x8d, 0xfc, 0xff, 0xff, 0x5b, 0x59, 0xb3, 0x02, 0xe9, 0xbb, 0xfe, 0xff, 0xff, 0x80, 0xfb, 0x03, 0x0f, 0x84, 0xb2, 0xfe, 0xff, 0xff, 0x80, 0xfb, 0x02, 0x75, 0x0c, 0x81, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x84, 0xa1, 0xfe, 0xff, 0xff, 0x51, 0xe8, 0x04, 0xfd, 0xff, 0xff, 0x59, 0x89, 0xc8, 0xc3};
  // Header de bytes para windows PE32
  // byte header[] = {0x4D, 0x5A, 0x60, 0x01, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x57, 0x69, 0x6E, 0x33, 0x32, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x6F, 0x6C, 0x65, 0x20, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x49, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x75, 0x6E, 0x64, 0x65, 0x72, 0x20, 0x4D, 0x53, 0x2D, 0x44, 0x4F, 0x53, 0x2E, 0x0D, 0x0A, 0x24, 0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x4C, 0x01, 0x01, 0x00, 0x00, 0x00, 0x53, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x02, 0x01, 0x0B, 0x01, 0x01, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x10, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6E, 0x10, 0x00, 0x00, 0x7C, 0x10, 0x00, 0x00, 0x8C, 0x10, 0x00, 0x00, 0x98, 0x10, 0x00, 0x00, 0xA4, 0x10, 0x00, 0x00, 0xB6, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4B, 0x45, 0x52, 0x4E, 0x45, 0x4C, 0x33, 0x32, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x00, 0x6E, 0x10, 0x00, 0x00, 0x7C, 0x10, 0x00, 0x00, 0x8C, 0x10, 0x00, 0x00, 0x98, 0x10, 0x00, 0x00, 0xA4, 0x10, 0x00, 0x00, 0xB6, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x78, 0x69, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x00, 0x00, 0x00, 0x47, 0x65, 0x74, 0x53, 0x74, 0x64, 0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x00, 0x00, 0x00, 0x00, 0x52, 0x65, 0x61, 0x64, 0x46, 0x69, 0x6C, 0x65, 0x00, 0x00, 0x00, 0x00, 0x57, 0x72, 0x69, 0x74, 0x65, 0x46, 0x69, 0x6C, 0x65, 0x00, 0x00, 0x00, 0x47, 0x65, 0x74, 0x43, 0x6F, 0x6E, 0x73, 0x6F, 0x6C, 0x65, 0x4D, 0x6F, 0x64, 0x65, 0x00, 0x00, 0x00, 0x00, 0x53, 0x65, 0x74, 0x43, 0x6F, 0x6E, 0x73, 0x6F, 0x6C, 0x65, 0x4D, 0x6F, 0x64, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0xA2, 0x1C, 0x11, 0x40, 0x00, 0x31, 0xC0, 0x03, 0x05, 0x2C, 0x11, 0x40, 0x00, 0x75, 0x0D, 0x6A, 0xF5, 0xFF, 0x15, 0x04, 0x10, 0x40, 0x00, 0xA3, 0x2C, 0x11, 0x40, 0x00, 0x6A, 0x00, 0x68, 0x30, 0x11, 0x40, 0x00, 0x6A, 0x01, 0x68, 0x1C, 0x11, 0x40, 0x00, 0x50, 0xFF, 0x15, 0x0C, 0x10, 0x40, 0x00, 0x09, 0xC0, 0x75, 0x08, 0x6A, 0x00, 0xFF, 0x15, 0x00, 0x10, 0x40, 0x00, 0x81, 0x3D, 0x30, 0x11, 0x40, 0x00, 0x01, 0x00, 0x00, 0x00, 0x75, 0xEC, 0x58, 0xC3, 0x00, 0x57, 0x72, 0x69, 0x74, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x31, 0xC0, 0x03, 0x05, 0xCC, 0x11, 0x40, 0x00, 0x75, 0x37, 0x6A, 0xF6, 0xFF, 0x15, 0x04, 0x10, 0x40, 0x00, 0xA3, 0xCC, 0x11, 0x40, 0x00, 0x68, 0xD0, 0x11, 0x40, 0x00, 0x50, 0xFF, 0x15, 0x10, 0x10, 0x40, 0x00, 0x80, 0x25, 0xD0, 0x11, 0x40, 0x00, 0xF9, 0xFF, 0x35, 0xD0, 0x11, 0x40, 0x00, 0xFF, 0x35, 0xCC, 0x11, 0x40, 0x00, 0xFF, 0x15, 0x14, 0x10, 0x40, 0x00, 0xA1, 0xCC, 0x11, 0x40, 0x00, 0x6A, 0x00, 0x68, 0xD4, 0x11, 0x40, 0x00, 0x6A, 0x01, 0x68, 0xBE, 0x11, 0x40, 0x00, 0x50, 0xFF, 0x15, 0x08, 0x10, 0x40, 0x00, 0x09, 0xC0, 0x61, 0x90, 0x75, 0x08, 0x6A, 0x00, 0xFF, 0x15, 0x00, 0x10, 0x40, 0x00, 0x0F, 0xB6, 0x05, 0xBE, 0x11, 0x40, 0x00, 0x81, 0x3D, 0xD4, 0x11, 0x40, 0x00, 0x01, 0x00, 0x00, 0x00, 0x74, 0x05, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x00, 0x52, 0x65, 0x61, 0x64, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x89, 0xC6, 0x30, 0xC0, 0x02, 0x06, 0x74, 0x08, 0x46, 0xE8, 0xE1, 0xFE, 0xFF, 0xFF, 0xEB, 0xF2, 0x61, 0x90, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x30, 0xE8, 0xC9, 0xFE, 0xFF, 0xFF, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x0D, 0xE8, 0xB9, 0xFE, 0xFF, 0xFF, 0xB0, 0x0A, 0xE8, 0xB2, 0xFE, 0xFF, 0xFF, 0xC3, 0x00, 0x3D, 0x00, 0x00, 0x00, 0x80, 0x75, 0x4E, 0xB0, 0x2D, 0xE8, 0xA2, 0xFE, 0xFF, 0xFF, 0xB0, 0x02, 0xE8, 0xCB, 0xFF, 0xFF, 0xFF, 0xB0, 0x01, 0xE8, 0xC4, 0xFF, 0xFF, 0xFF, 0xB0, 0x04, 0xE8, 0xBD, 0xFF, 0xFF, 0xFF, 0xB0, 0x07, 0xE8, 0xB6, 0xFF, 0xFF, 0xFF, 0xB0, 0x04, 0xE8, 0xAF, 0xFF, 0xFF, 0xFF, 0xB0, 0x08, 0xE8, 0xA8, 0xFF, 0xFF, 0xFF, 0xB0, 0x03, 0xE8, 0xA1, 0xFF, 0xFF, 0xFF, 0xB0, 0x06, 0xE8, 0x9A, 0xFF, 0xFF, 0xFF, 0xB0, 0x04, 0xE8, 0x93, 0xFF, 0xFF, 0xFF, 0xB0, 0x08, 0xE8, 0x8C, 0xFF, 0xFF, 0xFF, 0xC3, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x7D, 0x0B, 0x50, 0xB0, 0x2D, 0xE8, 0x4C, 0xFE, 0xFF, 0xFF, 0x58, 0xF7, 0xD8, 0x3D, 0x0A, 0x00, 0x00, 0x00, 0x0F, 0x8C, 0xEF, 0x00, 0x00, 0x00, 0x3D, 0x64, 0x00, 0x00, 0x00, 0x0F, 0x8C, 0xD1, 0x00, 0x00, 0x00, 0x3D, 0xE8, 0x03, 0x00, 0x00, 0x0F, 0x8C, 0xB3, 0x00, 0x00, 0x00, 0x3D, 0x10, 0x27, 0x00, 0x00, 0x0F, 0x8C, 0x95, 0x00, 0x00, 0x00, 0x3D, 0xA0, 0x86, 0x01, 0x00, 0x7C, 0x7B, 0x3D, 0x40, 0x42, 0x0F, 0x00, 0x7C, 0x61, 0x3D, 0x80, 0x96, 0x98, 0x00, 0x7C, 0x47, 0x3D, 0x00, 0xE1, 0xF5, 0x05, 0x7C, 0x2D, 0x3D, 0x00, 0xCA, 0x9A, 0x3B, 0x7C, 0x13, 0xBA, 0x00, 0x00, 0x00, 0x00, 0xBB, 0x00, 0xCA, 0x9A, 0x3B, 0xF7, 0xFB, 0x52, 0xE8, 0x18, 0xFF, 0xFF, 0xFF, 0x58, 0xBA, 0x00, 0x00, 0x00, 0x00, 0xBB, 0x00, 0xE1, 0xF5, 0x05, 0xF7, 0xFB, 0x52, 0xE8, 0x05, 0xFF, 0xFF, 0xFF, 0x58, 0xBA, 0x00, 0x00, 0x00, 0x00, 0xBB, 0x80, 0x96, 0x98, 0x00, 0xF7, 0xFB, 0x52, 0xE8, 0xF2, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x00, 0x00, 0x00, 0x00, 0xBB, 0x40, 0x42, 0x0F, 0x00, 0xF7, 0xFB, 0x52, 0xE8, 0xDF, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x00, 0x00, 0x00, 0x00, 0xBB, 0xA0, 0x86, 0x01, 0x00, 0xF7, 0xFB, 0x52, 0xE8, 0xCC, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x00, 0x00, 0x00, 0x00, 0xBB, 0x10, 0x27, 0x00, 0x00, 0xF7, 0xFB, 0x52, 0xE8, 0xB9, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x00, 0x00, 0x00, 0x00, 0xBB, 0xE8, 0x03, 0x00, 0x00, 0xF7, 0xFB, 0x52, 0xE8, 0xA6, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x00, 0x00, 0x00, 0x00, 0xBB, 0x64, 0x00, 0x00, 0x00, 0xF7, 0xFB, 0x52, 0xE8, 0x93, 0xFE, 0xFF, 0xFF, 0x58, 0xBA, 0x00, 0x00, 0x00, 0x00, 0xBB, 0x0A, 0x00, 0x00, 0x00, 0xF7, 0xFB, 0x52, 0xE8, 0x80, 0xFE, 0xFF, 0xFF, 0x58, 0xE8, 0x7A, 0xFE, 0xFF, 0xFF, 0xC3, 0x00, 0xFF, 0x15, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x00, 0x00, 0x00, 0xB3, 0x03, 0x51, 0x53, 0xE8, 0xA2, 0xFD, 0xFF, 0xFF, 0x5B, 0x59, 0x3C, 0x0D, 0x0F, 0x84, 0x34, 0x01, 0x00, 0x00, 0x3C, 0x08, 0x0F, 0x84, 0x94, 0x00, 0x00, 0x00, 0x3C, 0x2D, 0x0F, 0x84, 0x09, 0x01, 0x00, 0x00, 0x3C, 0x30, 0x7C, 0xDB, 0x3C, 0x39, 0x7F, 0xD7, 0x2C, 0x30, 0x80, 0xFB, 0x00, 0x74, 0xD0, 0x80, 0xFB, 0x02, 0x75, 0x0C, 0x81, 0xF9, 0x00, 0x00, 0x00, 0x00, 0x75, 0x04, 0x3C, 0x00, 0x74, 0xBF, 0x80, 0xFB, 0x03, 0x75, 0x0A, 0x3C, 0x00, 0x75, 0x04, 0xB3, 0x00, 0xEB, 0x02, 0xB3, 0x01, 0x81, 0xF9, 0xCC, 0xCC, 0xCC, 0x0C, 0x7F, 0xA8, 0x81, 0xF9, 0x34, 0x33, 0x33, 0xF3, 0x7C, 0xA0, 0x88, 0xC7, 0xB8, 0x0A, 0x00, 0x00, 0x00, 0xF7, 0xE9, 0x3D, 0x08, 0x00, 0x00, 0x80, 0x74, 0x11, 0x3D, 0xF8, 0xFF, 0xFF, 0x7F, 0x75, 0x13, 0x80, 0xFF, 0x07, 0x7E, 0x0E, 0xE9, 0x7F, 0xFF, 0xFF, 0xFF, 0x80, 0xFF, 0x08, 0x0F, 0x8F, 0x76, 0xFF, 0xFF, 0xFF, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x88, 0xF9, 0x80, 0xFB, 0x02, 0x74, 0x04, 0x01, 0xC1, 0xEB, 0x03, 0x29, 0xC8, 0x91, 0x88, 0xF8, 0x51, 0x53, 0xE8, 0xC3, 0xFD, 0xFF, 0xFF, 0x5B, 0x59, 0xE9, 0x53, 0xFF, 0xFF, 0xFF, 0x80, 0xFB, 0x03, 0x0F, 0x84, 0x4A, 0xFF, 0xFF, 0xFF, 0x51, 0x53, 0xB0, 0x08, 0xE8, 0x7A, 0xFC, 0xFF, 0xFF, 0xB0, 0x20, 0xE8, 0x73, 0xFC, 0xFF, 0xFF, 0xB0, 0x08, 0xE8, 0x6C, 0xFC, 0xFF, 0xFF, 0x5B, 0x59, 0x80, 0xFB, 0x00, 0x75, 0x07, 0xB3, 0x03, 0xE9, 0x25, 0xFF, 0xFF, 0xFF, 0x80, 0xFB, 0x02, 0x75, 0x0F, 0x81, 0xF9, 0x00, 0x00, 0x00, 0x00, 0x75, 0x07, 0xB3, 0x03, 0xE9, 0x11, 0xFF, 0xFF, 0xFF, 0x89, 0xC8, 0xB9, 0x0A, 0x00, 0x00, 0x00, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x7D, 0x08, 0xF7, 0xD8, 0xF7, 0xF9, 0xF7, 0xD8, 0xEB, 0x02, 0xF7, 0xF9, 0x89, 0xC1, 0x81, 0xF9, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x85, 0xE6, 0xFE, 0xFF, 0xFF, 0x80, 0xFB, 0x02, 0x0F, 0x84, 0xDD, 0xFE, 0xFF, 0xFF, 0xB3, 0x03, 0xE9, 0xD6, 0xFE, 0xFF, 0xFF, 0x80, 0xFB, 0x03, 0x0F, 0x85, 0xCD, 0xFE, 0xFF, 0xFF, 0xB0, 0x2D, 0x51, 0x53, 0xE8, 0xFD, 0xFB, 0xFF, 0xFF, 0x5B, 0x59, 0xB3, 0x02, 0xE9, 0xBB, 0xFE, 0xFF, 0xFF, 0x80, 0xFB, 0x03, 0x0F, 0x84, 0xB2, 0xFE, 0xFF, 0xFF, 0x80, 0xFB, 0x02, 0x75, 0x0C, 0x81, 0xF9, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x84, 0xA1, 0xFE, 0xFF, 0xFF, 0x51, 0xE8, 0x14, 0xFD, 0xFF, 0xFF, 0x59, 0x89, 0xC8, 0xC3};
  for (int i = 0; i < sizeof(header); i++) {
    cargarByte(mem, header[i]);
  }
}

// Escribe archivo binario con el contenido del array de bytes
void dumpToFile(memoria *mem) {
    FILE * fp;
    fp = fopen(OUTPUT_FILE, "wb");
    fwrite(mem->bytesArray, sizeof(byte), mem->posicion, fp);
    fclose(fp);
}

// Devuelve nombre de archivo ejecutable
void getNombre(char *arg, char **output) {
    char *token;
    int len = 0;
    token = strtok(arg, ".");

    while (token[len] != '\0') {
        len++;
    }

    strcat(*output, token);
    strcat(*output, ".exe");
}
// ####################################################################################################################
// ################################################ Analizador Lexico #################################################
// ####################################################################################################################

tSimbolo aLex(FILE *fp) {
  tSimbolo a;
  a.cadena[0] = '\0';
  char c;
  do {
    c = getc(fp);
  } while (c != EOF && !isgraph(c));
  // Corta cuando c == EOF o cuando isgraph(c) == true

  if (c == EOF) {
    a.simbolo = FIN_DE_ARCHIVO;
  } else {
    concatenar(a.cadena, c);
    if (isalpha(c)) {
      do {
        c = getc(fp);
        if (isalpha(c) || isdigit(c))
          concatenar(a.cadena, c);
      } while (c != EOF && (isalpha(c) || isdigit(c)));
      // Corta cuando c==EOF o cuando c no es letra ni dígito

      ungetc(c, fp);
      // El char que provoco el fin de la cadena debe volver a
      // leerse en el próximo llamado a aLex

      char cadenaAux[MAX_LONGITUD_CADENA + 3];
      // Más los apóstrofos y el \0 final

      strcpy(cadenaAux, a.cadena);
      uppercase(cadenaAux);

      if (strcmp(cadenaAux, "BEGIN") == 0)
        a.simbolo = BEGIN;
      else if (strcmp(cadenaAux, "CALL") == 0)
        a.simbolo = CALL;
      else if (strcmp(cadenaAux, "CONST") == 0)
        a.simbolo = CONST;
      else if (strcmp(cadenaAux, "DO") == 0)
        a.simbolo = DO;
      else if (strcmp(cadenaAux, "END") == 0)
        a.simbolo = END;
      else if (strcmp(cadenaAux, "IF") == 0)
        a.simbolo = IF;
      else if (strcmp(cadenaAux, "ODD") == 0)
        a.simbolo = ODD;
      else if (strcmp(cadenaAux, "PROCEDURE") == 0)
        a.simbolo = PROCEDURE;
      else if (strcmp(cadenaAux, "READLN") == 0)
        a.simbolo = READLN;
      else if (strcmp(cadenaAux, "THEN") == 0)
        a.simbolo = THEN;
      else if (strcmp(cadenaAux, "VAR") == 0)
        a.simbolo = VAR;
      else if (strcmp(cadenaAux, "WHILE") == 0)
        a.simbolo = WHILE;
      else if (strcmp(cadenaAux, "WRITE") == 0)
        a.simbolo = WRITE;
      else if (strcmp(cadenaAux, "WRITELN") == 0)
        a.simbolo = WRITELN;
      else
        a.simbolo = IDENT;
    } else if (isdigit(c)) {
      do {
        c = getc(fp);
        if (isdigit(c))
          concatenar(a.cadena, c);
      } while (c != EOF && isdigit(c));
      // Corta cuando c==EOF o cuando c no es dígito

      ungetc(c, fp);
      // El char que provoco el fin de la cadena debe volver a
      // leerse en el próximo llamado a aLex

      a.simbolo = NUMERO;
    } else {
      switch (c) {

      case '\'':
        do {
          c = getc(fp);
          if (c != EOF && c != '\n')
            concatenar(a.cadena, c);
        } while (c != EOF && c != '\n' && c != '\'');
        // Corta cuando c==EOF o c=='\n' o cuando c es un apóstrofo

        if (c == EOF || c == '\n') {
          a.simbolo = NULO;
          ungetc(c, fp);
        } else {
          a.simbolo = CADENA;
        }
        break;

      case '.':
        a.simbolo = PUNTO;
        break;

      case ',':
        a.simbolo = COMA;
        break;

      case ';':
        a.simbolo = PTOCOMA;
        break;

      case '+':
        a.simbolo = MAS;
        break;

      case '-':
        a.simbolo = MENOS;
        break;

      case '*':
        a.simbolo = POR;
        break;

      case '/':
        a.simbolo = DIVIDIDO;
        break;

      case '(':
        a.simbolo = ABREPAREN;
        break;

      case ')':
        a.simbolo = CIERRAPAREN;
        break;

      case '<':
        c = getc(fp);
        if (c == '=') {
          concatenar(a.cadena, c);
          a.simbolo = MENORIGUAL;
        } else if (c == '>') {
          concatenar(a.cadena, c);
          a.simbolo = DISTINTO;
        } else {
          ungetc(c, fp);
          a.simbolo = MENOR;
        }
        break;

      case '>':
        c = getc(fp);
        if (c == '=') {
          concatenar(a.cadena, c);
          a.simbolo = MAYORIGUAL;
        } else {
          ungetc(c, fp);
          a.simbolo = MAYOR;
        }
        break;

      case '=':
        a.simbolo = IGUAL;
        break;

      case ':':
        c = getc(fp);
        if (c == '=') {
          concatenar(a.cadena, c);
          a.simbolo = ASIGNACION;
        } else {
          ungetc(c, fp);
          a.simbolo = NULO;
        }
        break;
      default:
        a.simbolo = NULO;
      }
    }
  }

  imprimir(a);

  return a;
}

// ####################################################################################################################
// ############################################### Analizador sintactico ##############################################
// ####################################################################################################################

tSimbolo programa(tSimbolo s, FILE *archivo, memoria **memArray) {
  // Declaramos tabla de identificadores para el analizador semantico
  tablaDeIdent tabla;
  // cargarHeader(memArray);
  // dumpToFile(*memArray);

  // Aca hay que cargar MOV, EDI ...., después de haber generado el header y E/S

  s = bloque(s, archivo, memArray, tabla, 0);
  if (s.simbolo == PUNTO)
    s = aLex(archivo);
  else
    error(1, s);
  return s;
}

tSimbolo bloque(tSimbolo s, FILE *archivo, memoria **memArray, tablaDeIdent tabla, int base) {
  int desplazamiento = 0;
  int p;

  // Agregar salto condicional al inicio de bloque, antes de todo (E9 00 00 00 00)

  if (s.simbolo == CONST) {
    s = aLex(archivo);
    if (s.simbolo == IDENT) {
      p = buscarIdent(s.cadena, tabla, base, (base + desplazamiento - 1));
      // Si no encuentro el identificador en la tabla, lo agrego
      if (p == -1) {
        tabla[base + desplazamiento].tipo = CONST;
        strcpy(tabla[base + desplazamiento].nombre, s.cadena);
      } else error(13, s);
      s = aLex(archivo);
    } else error(2, s);

    if (s.simbolo == IGUAL) {
      s = aLex(archivo);
    } else error(3, s);

    if (s.simbolo == NUMERO) {
      tabla[base + desplazamiento].valor = atoi(s.cadena);
      desplazamiento++;
      s = aLex(archivo);
    } else error(4, s);

    while (s.simbolo == COMA) {
      s = aLex(archivo);

      if (s.simbolo == IDENT) {
        p = buscarIdent(s.cadena, tabla, base, (base + desplazamiento - 1));
        // Si no encuentro el identificador en la tabla, lo agrego
        if (p == -1) {
          tabla[base + desplazamiento].tipo = CONST;
          strcpy(tabla[base + desplazamiento].nombre, s.cadena);
        } else error(13, s);
        s = aLex(archivo);
      } else error(2, s);

      if (s.simbolo == IGUAL) {
        s = aLex(archivo);
      } else error(3, s);

      if (s.simbolo == NUMERO) {
        tabla[base + desplazamiento].valor = atoi(s.cadena);
        desplazamiento++;
        s = aLex(archivo);
      } else error(4, s);

    }
    if (s.simbolo == PTOCOMA){
      s = aLex(archivo);
    } else error(5, s);
  }

  if (s.simbolo == VAR) {
    s = aLex(archivo);

    if (s.simbolo == IDENT) {
      p = buscarIdent(s.cadena, tabla, base, (base + desplazamiento - 1));
      if (p == -1) {
        tabla[base + desplazamiento].tipo = VAR;
        strcpy(tabla[base + desplazamiento].nombre, s.cadena);
        tabla[base + desplazamiento].valor = 0;
        desplazamiento++;
      } else error(13, s);
      s = aLex(archivo);
    } else error(2, s);

    while (s.simbolo == COMA) {
      s = aLex(archivo);
      if (s.simbolo == IDENT) {
        p = buscarIdent(s.cadena, tabla, base, (base + desplazamiento - 1));
        if (p == -1) {
          tabla[base + desplazamiento].tipo = VAR;
          strcpy(tabla[base + desplazamiento].nombre, s.cadena);
          tabla[base + desplazamiento].valor = 0;
          desplazamiento++;
        } else error(13, s);

        s = aLex(archivo);
      } else error(2, s);
    }

    if (s.simbolo == PTOCOMA)
      s = aLex(archivo);
    else error(5, s);
  }

  while (s.simbolo == PROCEDURE) {
    s = aLex(archivo);

    if (s.simbolo == IDENT) {
      p = buscarIdent(s.cadena, tabla, base, (base + desplazamiento - 1));
      if (p == -1) {
        tabla[base + desplazamiento].tipo = PROCEDURE;
        strcpy(tabla[base + desplazamiento].nombre, s.cadena);
        tabla[base + desplazamiento].valor = 0;
        desplazamiento++;
      } else error(13, s);
      s = aLex(archivo);
    } else error(2, s);

    if (s.simbolo = PTOCOMA) {
      s = aLex(archivo);
    } else error(5, s);

    s = bloque(s, archivo, memArray, tabla, base + desplazamiento);
    // Debería insertar una instruccion C3 RET (El final del bloque)
    if (s.simbolo == PTOCOMA) {
      s = aLex(archivo);
    } else error(5, s);
  }

  s = proposicion(s, archivo, memArray, tabla, (base + desplazamiento - 1));
  return s;
}

tSimbolo proposicion(tSimbolo s, FILE *archivo, memoria **memArray, tablaDeIdent tabla, int posUltimoIdent) {

  switch (s.simbolo) {
  case IDENT:
    if (esIdentDeTipo(s.cadena, tabla, posUltimoIdent, VAR)) {
      s = aLex(archivo);
    } else error(17, s); // Error semantico, se esperaba un VAR
    if (s.simbolo == ASIGNACION) {
      s = aLex(archivo);
    } else error(6, s); // Error sintactico, se esperaba asignacion
    s = expresion(s, archivo, memArray, tabla, posUltimoIdent);
    break;
  case CALL:
    s = aLex(archivo);
    if (s.simbolo == IDENT) {
      if (esIdentDeTipo(s.cadena, tabla, posUltimoIdent, PROCEDURE)) {
        s = aLex(archivo);
      } else error(16, s); // Error semantico, se esparaba un PROCEDURE
    } else error(2, s);
    break;
  case BEGIN:
    s = aLex(archivo);
    s = proposicion(s, archivo, memArray, tabla, posUltimoIdent);
    while (s.simbolo == PTOCOMA) {
      s = aLex(archivo);
      s = proposicion(s, archivo, memArray, tabla, posUltimoIdent);
    }
    if (s.simbolo == END)
      s = aLex(archivo);
    else
      error(7, s); // Se esperaba END
    break;
  case IF:
    s = aLex(archivo);
    s = condicion(s, archivo, memArray, tabla, posUltimoIdent);
    if (s.simbolo == THEN)
      s = aLex(archivo);
    else
      error(8, s); // Se esperaba THEN
    s = proposicion(s, archivo, memArray, tabla, posUltimoIdent);
    break;
  case WHILE:
    s = aLex(archivo);
    s = condicion(s, archivo, memArray, tabla, posUltimoIdent);
    if (s.simbolo == DO)
      s = aLex(archivo);
    else
      error(9, s); // Se esperaba DO
    s = proposicion(s, archivo, memArray, tabla, posUltimoIdent);
    break;
  case READLN:
    // int p;
    s = aLex(archivo);
    if (s.simbolo == ABREPAREN)
      s = aLex(archivo);
    else
      error(10, s); // Se esperaba ABREPAREN
    if (s.simbolo == IDENT) {
      int p = buscarIdent(s.cadena, tabla, 0, posUltimoIdent);
      if (p != -1) {
        if (tabla[p].tipo != VAR) {
          error(14, s);
        }
      }
      s = aLex(archivo);
    } else
      error(2, s); // Se esperaba IDENT
    while (s.simbolo == COMA) {
      s = aLex(archivo);
      if (s.simbolo == IDENT)
        s = aLex(archivo);
      else
        error(2, s); // Se esperaba IDENT
    }
    if (s.simbolo == CIERRAPAREN)
      s = aLex(archivo);
    else
      error(11, s); // Se esperaba CIERRAPAREN
    break;
  case WRITE:
    s = aLex(archivo);
    if (s.simbolo == ABREPAREN)
      s = aLex(archivo);
    else
      error(10, s);
    if (s.simbolo == CADENA)
      s = aLex(archivo);
    else
      s = expresion(s, archivo, memArray, tabla, posUltimoIdent);
    while (s.simbolo == COMA) {
      s = aLex(archivo);
      if (s.simbolo == CADENA)
        s = aLex(archivo);
      else
        s = expresion(s, archivo, memArray, tabla, posUltimoIdent);
    }
    // else expresion(s, archivo, posUltimoIdent);
    if (s.simbolo == CIERRAPAREN)
      s = aLex(archivo);
    else
      error(11, s); // Se esperaba CIERRAPAREN
    break;
  case WRITELN:
    // probar esto, medio dudoso y mal explicado
    s = aLex(archivo);
    if (s.simbolo == PTOCOMA) return s;
    if (s.simbolo == ABREPAREN) {
      s = aLex(archivo);
      if (s.simbolo == CADENA) {
        s = aLex(archivo);
      } else {
        s = expresion(s, archivo, memArray, tabla, posUltimoIdent);
      }
      while (s.simbolo == COMA) {
        s = aLex(archivo);
        if (s.simbolo == CADENA) {
          s = aLex(archivo);
        } else {
          s = expresion(s, archivo, memArray, tabla, posUltimoIdent);
        }
      }
      if (s.simbolo == CIERRAPAREN) {
        s = aLex(archivo);
      } else error(11, s); // Se esperaba CIERRAPAREN
    } else error(10, s);
  }
  return s;
}

tSimbolo condicion(tSimbolo s, FILE *archivo, memoria **memArray, tablaDeIdent tabla, int posUltimoIdent) {

  if (s.simbolo == ODD) {
    s = aLex(archivo);
    s = expresion(s, archivo, memArray, tabla, posUltimoIdent);
  } else {
    s = expresion(s, archivo, memArray, tabla, posUltimoIdent);
    switch (s.simbolo) {
    case IGUAL:
      s = aLex(archivo);
      break;
    case DISTINTO:
      s = aLex(archivo);
      break;
    case MAYOR:
      s = aLex(archivo);
      break;
    case MENOR:
      s = aLex(archivo);
      break;
    case MAYORIGUAL:
      s = aLex(archivo);
      break;
    case MENORIGUAL:
      s = aLex(archivo);
      break;
    default:
      error(12, s);
    }
  }
  s = expresion(s, archivo, memArray, tabla, posUltimoIdent);
  return s;
}

tSimbolo expresion(tSimbolo s, FILE *archivo, memoria **memArray, tablaDeIdent tabla, int posUltimoIdent) {

  if (s.simbolo == MAS)
    s = aLex(archivo);
  else if (s.simbolo == MENOS)
    s = aLex(archivo);
  s = termino(s, archivo, memArray, tabla, posUltimoIdent);
  while (s.simbolo == MAS || s.simbolo == MENOS) {
    s = aLex(archivo);
    s = termino(s, archivo, memArray, tabla, posUltimoIdent);
  }
  return s;
}

tSimbolo termino(tSimbolo s, FILE *archivo, memoria **memArray, tablaDeIdent tabla, int posUltimoIdent) {

  s = factor(s, archivo, memArray, tabla, posUltimoIdent);
  while (s.simbolo == POR || s.simbolo == DIVIDIDO) {
    s = aLex(archivo);
    s = factor(s, archivo, memArray, tabla, posUltimoIdent);
  }
  return s;
}

tSimbolo factor(tSimbolo s, FILE *archivo, memoria **memArray, tablaDeIdent tabla, int posUltimoIdent) {
  switch (s.simbolo) {
  case IDENT:
    if (!esIdentDeTipo(s.cadena, tabla, posUltimoIdent, PROCEDURE)) {
      s = aLex(archivo);
    } else error(18, s);
    break;
  case NUMERO:
    s = aLex(archivo);
    break;
  case ABREPAREN:
    s = aLex(archivo);
    s = expresion(s, archivo, memArray, tabla, posUltimoIdent);
    if (s.simbolo == CIERRAPAREN)
      s = aLex(archivo);
    else
      error(11, s); // Se esperaba CIERRAPAREN
    break;
  }
  return s;
}













/**
  Analizador Semantico

  En BLOQUE:
  - Carga a la tabla todos los identificadores

  En PROPOSICION:
  - En asignacion debe validar que el identificador sea de tipo VAR, sino devuelve "Error, se esperaba una asignacion a un VAR"
  - En CALL debe validar que el identificador sea de tipo PROCEDURE, sino devuelve "Error, se esperaba un procedure"

  En FACTOR:
  - Debe validar que el identificador no sea de tipo PROCEDURE, sino devuelve "Error, se esperaba un numero entero"
**/